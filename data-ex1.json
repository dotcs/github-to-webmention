{
  "items": [
    {
      "type": ["h-card"],
      "properties": {
        "url": ["/"],
        "name": ["Keith J. Grant"],
        "photo": ["/images/keithjgrant.jpg"]
      }
    },
    {
      "type": ["h-entry"],
      "properties": {
        "name": ["Resilient, Declarative, Contextual"],
        "url": [
          "https://keithjgrant.com/posts/2018/06/resilient-declarative-contextual/"
        ],
        "published": [""],
        "content": [
          {
            "value":
              "I’ve spent a lot of time thinking about what defines a CSS mindset. Some people seem to “get” it, and others don’t. It’s always felt to me that if I could put my finger on that, maybe CSS would make more sense to those who have struggled with it. One piece of my motivation in writing CSS in Depth was to try to articulate some of those things.\n\n\n\nToday I want to take a different tack. I want to look at three key characteristics of CSS that set it apart from conventional programming languages: it’s resilient; it’s declarative; and it’s contextual. Understanding these aspects of the language, I think, is key to becoming proficient in CSS.\n\nCSS is resilient\n\nIf you were to randomly delete a chunk of code out of a JavaScript file, the app or page using it would almost certainly come crashing to a halt and much of the script (if not the page as a whole) would become useless. If you do the same thing to CSS, you might not even notice. Almost everything apart from that specific section of code will continue to work as intended.\n\nWe call this resilience. HTML and CSS were specifically designed to be fault-tolerant. If there’s a problem, the browser won’t throw an error; instead, it will ignore that part of the code and keep on going.\n\nThis may seem absurd from a debugging perspective: if it doesn’t throw errors, how do you know what went wrong? But this is an essential piece to how CSS works. It’s woven into the fabric of the language itself. It may take some getting used to, I admit. Once you understand this, though, you can safely use features that aren’t supported in all browsers. This is what makes progressive enhancement possible.\n\nConsider this example of a grid layout. It works in browsers that support grid, and it works in browsers that don’t support grid. It will be slightly imperfect in those that don’t support grid (the exact sizes of the items will probably vary), but it will still layout the page in roughly the same way:\n\n.portfolio {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));\n}\n\n.portfolio__item {\n  display: inline-block;\n  max-width: 600px;\n}\n\n\nA browser that doesn’t understand the two grid declarations will ignore them, and the other rules will do the work. And a browser that does understand grid will use the grid layout and ignore the inline-block declaration (because that’s how grid was designed to work). Jen Simmons half-jokingly calls this “Quantum CSS”. You can take a feature of CSS and “use it and not use it at the same time. It works and it doesn’t work at the same time.”\n\nThis concept of “fallback” behavior is integral to using CSS, but it is a foreign concept in most conventional programming languages.\n\nCSS is declarative\n\nIn JavaScript, you give specific, step-by-step instructions how to make something happen. In CSS, you tell the browser what you want to have happen, and it works out the how. This is extremely important to understand. If you get it right, CSS will do all the hard work for you! And if you get it wrong, you’ll be fighting against the grain of the language and you will be frustrated at every turn.\n\nWriting CSS is effectively setting up a system of constraints. You don’t tell the browser where to put every single element on the page; you tell it how much space to put between them and let it sort out where they belong. You don’t tell it (or at least shouldn’t tell it) how tall to make a container; you let it figure that out at render time when it knows the contents of the container, which other styles are applied, and how much width is available in the viewport.\n\nThere are too many variables to consider. The point of CSS is to make it so you don’t have to worry about them all. Define some constraints. Let the language work out the details.\n\nA simple example\n\nLet’s consider this CSS for a moment: font-size: 2em. What does it do? “It increases the font size,” you say. But that’s not all. It also adjusts the line wrapping of text in the container, as fewer words will now fit on each line. That in turn will often increase the number of lines of text: so it will also increase the container’s height to contain the new lines of text. When the container’s height changes, anything beneath it on the page will be shifted down accordingly. Finally, it also specifies a value for the local meaning of em. Any other properties defined using ems will have their computed values updated to match.\n\nThat one declaration creates a whole slew of changes on the page. And they’re all exactly what you should want: the content will always fit, elements aren’t going to wind up overlapping oddly, and anything defined in terms of the font size (like padding, perhaps) will adapt. You don’t have to worry about those details. The browser makes all those calculations and does the work by default.\n\nIf you want to stop these things from happening, you can. You could cap the container height with a max-height and overflow: auto. You could redefine padding to be in rems or px so it doesn’t adapt to the local font size. This highlights an interesting part of writing CSS: sometimes you’re not telling the browser what to do; you’re effectively telling it what not to do.\n\nGriddy goodness\n\nSome of the newer features in CSS do even more. Flexbox and Grid are prime examples of this. With just a few declarations, you can build a grid layout that is extremely flexible and “just works”. You don’t have to worry about countless edge cases. You say, effectively “put these boxes in columns of about 400px wide” and it will do it for you. It takes about three lines of code.\n\nIf you were to do this imperatively, you would need to deal with all sorts of odd scenarios. What if there’s an extremely long word in one of the boxes? What if the viewport is very narrow? What if it’s very wide? What if one box has a ton of content and another contains just a few words? But chances are, in CSS, you don’t need to think about any of these things. All the hard thought for this has already gone into the spec, and the browser takes care of it for you. This is the power of a declarative language.\n\nThis does come with a trade-off: if the declarative language doesn’t support something you want to do (say, a “masonry” layout), you’re left relying on either odd hacks or JavaScript to help accomplish it. And for years, this sort of thing was a large part of CSS development. Thankfully, with the rise of Flexbox and Grid, we can do far more than we could in the past, without any hacks (and yes, floats were a hack). If this limitation still bothers you, I suggest you read up on CSS Houdini, which is just beginning to land in browsers.\n\nCSS is contextual\n\nIn the React era, we have embraced the extremely useful approach of modular, component-based development. CSS best-practices do this as well, with BEM and SMACSS and CSS-in-JS. I don’t want to belittle this, because this is an essential way of thinking when building large-scale applications. But I think it’s equally important to acknowledge that CSS is not 100% modular, nor should it be.\n\nThere are two reasons for this. First, and most obvious, is that your app should have some global styles. You will almost always want to set a default typeface and font size at the page level. These values will then be inherited by all descendant elements that don’t explicitly override them. You will also want certain aspects of your design to apply repeatedly throughout the page, such as theme colors, border radii, box shadows, and common margin sizes. More localized styles on the page will then assume these global styles are in place.\n\nSecond, and more subtle, is the way CSS and your styling decisions are informed by the surrounding context of the page. Consider applying the following CSS to an element:\n\n.the-thing {\n  position: absolute;\n  top: 10px;\n  left: 10px;\n}\n\n\nWhat will this code do? Without knowledge of where the element is in the DOM and what styles are applied to the rest of the page, there is no way to know. Absolute positioning is done relative to the nearest positioned ancestor; applying it means different things depending on which ancestor, if any, has positioning applied.\n\nFurthermore, how you can (or cannot) stack one element in front of another is going to be highly dependent on where the two are positioned in the DOM. Shuffling items around in the DOM can cause drastic effects on the way items fit together and stack. This is why document flow and stacking contexts are a vital (and sometimes complicated) topics.\n\nThe contextual nature of CSS is also due in part to the way design works. If an engineer designs a bridge, you can’t just look at the blueprint and say, “this is all good except this one beam here; go ahead and take that out”. Removing that beam has ramifications on the structural integrity of the whole thing. Similarly, changing one part of a design can have ramifications on how other items on the screen are perceived. Frequently, you will need to style multiple elements together, in conjunction.\n\nIf you make the heading in a tile bigger, for instance, it becomes more prominent to the user and therefore makes other items on the screen seem less important. The restrictions aren’t about physics as with the bridge, but there are subtle rules of “soft science” that impact human perception. The parts of the page render in a physical space on screen, and the realities of the physical world (and how we perceive it) are important to be aware of.\n\nWe like to architect software using principles of modularity and encapsulation. This makes sense in the world of code, because code is complicated and this breaks the problem up into manageable sizes. But we should also be aware that it isn’t always perfect. In CSS, we can never completely disregard what’s going on outside a given module.\n\nSummary\n\nThese three aspects make CSS different than conventional programming languages. These differences may feel foreign, but it’s these differences that make CSS so powerful. And it’s my suspicion that developers who embrace these things, and have fully internalized them, tend to be far more proficient in CSS.",
            "html":
              "\n    <p>I’ve spent a lot of time thinking about what defines a CSS mindset. Some people seem to “get” it, and others don’t. It’s always felt to me that if I could put my finger on that, maybe CSS would make more sense to those who have struggled with it. One piece of my motivation in writing <a href=\"https://www.manning.com/books/css-in-depth\">CSS in Depth</a> was to try to articulate some of those things.</p>\n\n<p></p>\n\n<p>Today I want to take a different tack. I want to look at three key characteristics of CSS that set it apart from conventional programming languages: it’s resilient; it’s declarative; and it’s contextual. Understanding these aspects of the language, I think, is key to becoming proficient in CSS.</p>\n\n<h2 id=\"css-is-resilient\">CSS is resilient</h2>\n\n<p>If you were to randomly delete a chunk of code out of a JavaScript file, the app or page using it would almost certainly come crashing to a halt and much of the script (if not the page as a whole) would become useless. If you do the same thing to CSS, you might not even notice. Almost everything apart from that specific section of code will continue to work as intended.</p>\n\n<p>We call this <em>resilience</em>. HTML and CSS were specifically designed to be fault-tolerant. If there’s a problem, the browser won’t throw an error; instead, it will ignore that part of the code and keep on going.</p>\n\n<p>This may seem absurd from a debugging perspective: if it doesn’t throw errors, how do you know what went wrong? But this is an essential piece to how CSS works. It’s woven into the fabric of the language itself. It may take some getting used to, I admit. Once you understand this, though, you can safely use features that aren’t supported in all browsers. This is what makes progressive enhancement possible.</p>\n\n<p>Consider this example of a grid layout. It works in browsers that support grid, and it works in browsers that don’t support grid. It will be slightly imperfect in those that don’t support grid (the exact sizes of the items will probably vary), but it will still layout the page in roughly the same way:</p>\n\n<pre><code class=\"language-css\">.portfolio {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));\n}\n\n.portfolio__item {\n  display: inline-block;\n  max-width: 600px;\n}\n</code></pre>\n\n<p>A browser that doesn’t understand the two grid declarations will ignore them, and the other rules will do the work. And a browser that does understand grid will use the grid layout and ignore the <code>inline-block</code> declaration (because that’s how grid was designed to work). Jen Simmons half-jokingly calls this <a href=\"https://www.youtube.com/watch?v=u00FY9vADfQ\">“Quantum CSS”</a>. You can take a feature of CSS and “use it and not use it at the same time. It works and it doesn’t work at the same time.”</p>\n\n<p>This concept of “fallback” behavior is integral to using CSS, but it is a foreign concept in most conventional programming languages.</p>\n\n<h2 id=\"css-is-declarative\">CSS is declarative</h2>\n\n<p>In JavaScript, you give specific, step-by-step instructions how to make something happen. In CSS, you tell the browser what you want to have happen, and it works out the how. This is extremely important to understand. If you get it right, CSS will <a href=\"https://adactio.com/journal/13831\">do all the hard work for you</a>! And if you get it wrong, you’ll be fighting against the grain of the language and you will be frustrated at every turn.</p>\n\n<p>Writing CSS is effectively setting up a system of constraints. You don’t tell the browser where to put every single element on the page; you tell it how much space to put between them and let it sort out where they belong. You don’t tell it (or at least shouldn’t tell it) how tall to make a container; you let it figure that out at render time when it knows the contents of the container, which other styles are applied, and how much width is available in the viewport.</p>\n\n<p>There are too many variables to consider. The point of CSS is to make it so you don’t have to worry about them all. Define some constraints. Let the language work out the details.</p>\n\n<h3 id=\"a-simple-example\">A simple example</h3>\n\n<p>Let’s consider this CSS for a moment: <code>font-size: 2em</code>. What does it do? “It increases the font size,” you say. But that’s not all. It also adjusts the line wrapping of text in the container, as fewer words will now fit on each line. That in turn will often increase the number of lines of text: so it will also increase the container’s height to contain the new lines of text. When the container’s height changes, anything beneath it on the page will be shifted down accordingly. Finally, it also specifies a value for the local meaning of <code>em</code>. Any other properties defined using ems will have their computed values updated to match.</p>\n\n<p>That one declaration creates a whole slew of changes on the page. And they’re all exactly what you should want: the content will always fit, elements aren’t going to wind up overlapping oddly, and anything defined in terms of the font size (like padding, perhaps) will adapt. You don’t have to worry about those details. The browser makes all those calculations and does the work by default.</p>\n\n<p>If you want to stop these things from happening, you can. You could cap the container height with a <code>max-height</code> and <code>overflow: auto</code>. You could redefine padding to be in rems or px so it doesn’t adapt to the local font size. This highlights an interesting part of writing CSS: sometimes you’re not telling the browser what to do; you’re effectively telling it what <em>not</em> to do.</p>\n\n<h3 id=\"griddy-goodness\">Griddy goodness</h3>\n\n<p>Some of the newer features in CSS do even more. Flexbox and Grid are prime examples of this. With just a few declarations, you can build a grid layout that is extremely flexible and “just works”. You don’t have to worry about countless edge cases. You say, effectively “put these boxes in columns of about 400px wide” and it will do it for you. It takes about three lines of code.</p>\n\n<p>If you were to do this imperatively, you would need to deal with all sorts of odd scenarios. What if there’s an extremely long word in one of the boxes? What if the viewport is very narrow? What if it’s very wide? What if one box has a ton of content and another contains just a few words? But chances are, in CSS, you don’t need to think about any of these things. All the hard thought for this has already gone into the spec, and the browser takes care of it for you. This is the power of a declarative language.</p>\n\n<p>This does come with a trade-off: if the declarative language doesn’t support something you want to do (say, a “masonry” layout), you’re left relying on either odd hacks or JavaScript to help accomplish it. And for years, this sort of thing was a large part of CSS development. Thankfully, with the rise of Flexbox and Grid, we can do far more than we could in the past, without any hacks (and yes, floats were a hack). If this limitation still bothers you, I suggest you read up on <a href=\"https://www.smashingmagazine.com/2016/03/houdini-maybe-the-most-exciting-development-in-css-youve-never-heard-of/\">CSS Houdini</a>, which is just beginning to land in browsers.</p>\n\n<h2 id=\"css-is-contextual\">CSS is contextual</h2>\n\n<p>In the React era, we have embraced the extremely useful approach of modular, component-based development. CSS best-practices do this as well, with BEM and SMACSS and CSS-in-JS. I don’t want to belittle this, because this is an essential way of thinking when building large-scale applications. But I think it’s equally important to acknowledge that CSS is not 100% modular, nor should it be.</p>\n\n<p>There are two reasons for this. First, and most obvious, is that your app should have some global styles. You will almost always want to set a default typeface and font size at the page level. These values will then be inherited by all descendant elements that don’t explicitly override them. You will also want certain aspects of your design to apply repeatedly throughout the page, such as theme colors, border radii, box shadows, and common margin sizes. More localized styles on the page will then assume these global styles are in place.</p>\n\n<p>Second, and more subtle, is the way CSS and your styling decisions are informed by the surrounding context of the page. Consider applying the following CSS to an element:</p>\n\n<pre><code class=\"language-css\">.the-thing {\n  position: absolute;\n  top: 10px;\n  left: 10px;\n}\n</code></pre>\n\n<p>What will this code do? Without knowledge of where the element is in the DOM and what styles are applied to the rest of the page, there is no way to know. Absolute positioning is done relative to the nearest positioned ancestor; applying it means different things depending on which ancestor, if any, has positioning applied.</p>\n\n<p>Furthermore, how you can (or cannot) stack one element in front of another is going to be highly dependent on where the two are positioned in the DOM. Shuffling items around in the DOM can cause drastic effects on the way items fit together and stack. This is why document flow and stacking contexts are a vital (and sometimes complicated) topics.</p>\n\n<p>The contextual nature of CSS is also due in part to the way design works. If an engineer designs a bridge, you can’t just look at the blueprint and say, “this is all good except this one beam here; go ahead and take that out”. Removing that beam has ramifications on the structural integrity of the whole thing. Similarly, changing one part of a design can have ramifications on how other items on the screen are perceived. Frequently, you will need to style multiple elements together, in conjunction.</p>\n\n<p>If you make the heading in a tile bigger, for instance, it becomes more prominent to the user and therefore makes other items on the screen seem less important. The restrictions aren’t about physics as with the bridge, but there are subtle rules of “soft science” that impact human perception. The parts of the page render in a physical space on screen, and the realities of the physical world (and how we perceive it) are important to be aware of.</p>\n\n<p>We like to architect software using <a href=\"https://freecontent.manning.com/modular-css/\">principles of modularity and encapsulation</a>. This makes sense in the world of code, because code is complicated and this breaks the problem up into manageable sizes. But we should also be aware that it isn’t always perfect. In CSS, we can never completely disregard what’s going on outside a given module.</p>\n\n<h2 id=\"summary\">Summary</h2>\n\n<p>These three aspects make CSS different than conventional programming languages. These differences may feel foreign, but it’s these differences that make CSS so powerful. And it’s my suspicion that developers who embrace these things, and have fully internalized them, tend to be far more proficient in CSS.</p>\n  "
          }
        ]
      },
      "children": [
        {
          "type": ["h-entry"],
          "properties": {
            "author": ["", "", ""],
            "url": [""],
            "photo": [""],
            "entry": [{"value": "", "html": ""}]
          }
        },
        {
          "type": ["h-entry"],
          "properties": {
            "author": [
              {
                "type": ["h-card"],
                "properties": {
                  "url": [""],
                  "name": [""],
                  "author": [""],
                  "photo": [""]
                }
              }
            ]
          }
        }
      ]
    }
  ],
  "rels": {
    "stylesheet": ["/css/style.css"],
    "apple-touch-icon": ["/images/apple-icon-144.png"],
    "icon": [
      "/images/favicon-32.png",
      "/images/favicon-96.png",
      "/images/favicon-16.png"
    ],
    "alternate": ["/posts/index.xml", "/notes/index.xml"],
    "self": [
      "https://keithjgrant.com/posts/2018/06/resilient-declarative-contextual/"
    ],
    "hub": ["https://keithjgrant.superfeedr.com/"],
    "pingback": ["https://webmention.io/keithjgrant.com/xmlrpc"],
    "webmention": ["https://webmention.io/keithjgrant.com/webmention"],
    "authorization_endpoint": ["https://indieauth.com/auth"],
    "token_endpoint": ["https://tokens.indieauth.com/token"],
    "micropub": ["https://micropub.keithjgrant.com/micropub/main"],
    "preload": [
      "/fonts/glober-regular.woff2",
      "/fonts/glober-xbold.woff2",
      "/fonts/calendas_plus-webfont.woff2"
    ],
    "canonical": [
      "https://keithjgrant.com/posts/2018/06/resilient-declarative-contextual/"
    ],
    "me": ["https://twitter.com/keithjgrant", "https://github.com/keithjgrant"]
  },
  "rel-urls": {
    "/css/style.css": {"rels": ["stylesheet"]},
    "/images/apple-icon-144.png": {"rels": ["apple-touch-icon"]},
    "/images/favicon-32.png": {"type": "image/png", "rels": ["icon"]},
    "/images/favicon-96.png": {"type": "image/png", "rels": ["icon"]},
    "/images/favicon-16.png": {"type": "image/png", "rels": ["icon"]},
    "/posts/index.xml": {
      "type": "application/atom+xml",
      "title": "Posts",
      "rels": ["alternate"]
    },
    "/notes/index.xml": {
      "type": "application/atom+xml",
      "title": "Notes",
      "rels": ["alternate"]
    },
    "https://keithjgrant.com/posts/2018/06/resilient-declarative-contextual/": {
      "rels": ["self"]
    },
    "https://keithjgrant.superfeedr.com/": {"rels": ["hub"]},
    "https://webmention.io/keithjgrant.com/xmlrpc": {"rels": ["pingback"]},
    "https://webmention.io/keithjgrant.com/webmention": {
      "rels": ["webmention"]
    },
    "https://indieauth.com/auth": {"rels": ["authorization_endpoint"]},
    "https://tokens.indieauth.com/token": {"rels": ["token_endpoint"]},
    "https://micropub.keithjgrant.com/micropub/main": {"rels": ["micropub"]},
    "/fonts/glober-regular.woff2": {"type": "font/woff2", "rels": ["preload"]},
    "/fonts/glober-xbold.woff2": {"type": "font/woff2", "rels": ["preload"]},
    "/fonts/calendas_plus-webfont.woff2": {
      "type": "font/woff2",
      "rels": ["preload"]
    },
    "https://twitter.com/keithjgrant": {"text": "Twitter logo", "rels": ["me"]},
    "https://github.com/keithjgrant": {"text": "Github logo", "rels": ["me"]}
  }
}
